---
// This is an Astro client island that mounts a vanilla Three.js scene.
// Use it as: <PeriwinkleStarsea client:load />
---

<style>
  .sky-wrap {
    position: fixed;
    inset: 0;
    z-index: -1;       /* behind everything */
    pointer-events: none;
    background: #9098f0; /* fallback color while GL warms up */
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>

<div class="sky-wrap" aria-hidden="true">
  <canvas id="periwinkle-sky"></canvas>
</div>

<script type="module">
  // Respect reduced motion
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  import * as THREE from 'three';
  import { EffectComposer, RenderPass, EffectPass, BloomEffect } from 'postprocessing';

  const canvas = document.getElementById('periwinkle-sky');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: 'high-performance' });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  if (renderer.outputColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;

  // Scene + Camera
  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

  // ---- 1) Fullscreen quad with shader: gradient + nebula ----
  const quadGeo = new THREE.PlaneGeometry(2, 2);

  const nebulaMat = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0 },
      uPeriwinkleA: { value: new THREE.Color('#dfe2ff') }, // high haze
      uPeriwinkleB: { value: new THREE.Color('#aab2ff') }, // mid
      uPeriwinkleC: { value: new THREE.Color('#7d86e2') }, // deep
      uWarm: { value: new THREE.Color('#ffd3f6') },        // lilac kiss
      uCool: { value: new THREE.Color('#9fd7ff') },        // icy kiss
      uNoiseScale: { value: 1.2 },
      uNebulaStrength: { value: 0.8 },
      uVignette: { value: 0.5 },
      uMouse: { value: new THREE.Vector2(0.5, 0.5) },
      uScroll: { value: 0 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main(){
        vUv = uv;
        gl_Position = vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      precision highp float;
      varying vec2 vUv;

      uniform float uTime;
      uniform vec3 uPeriwinkleA, uPeriwinkleB, uPeriwinkleC, uWarm, uCool;
      uniform float uNoiseScale, uNebulaStrength, uVignette;
      uniform vec2 uMouse;
      uniform float uScroll;

      float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
      float noise(vec2 p){
        vec2 i = floor(p), f = fract(p);
        float a = hash(i);
        float b = hash(i + vec2(1.0, 0.0));
        float c = hash(i + vec2(0.0, 1.0));
        float d = hash(i + vec2(1.0, 1.0));
        vec2 u = f*f*(3.0-2.0*f);
        return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
      }
      float fbm(vec2 p){
        float v = 0.0;
        float a = 0.5;
        for(int i=0;i<6;i++){
          v += a * noise(p);
          p *= 2.0;
          a *= 0.5;
        }
        return v;
      }

      void main(){
        vec2 uv = vUv;
        vec2 par = (uMouse - 0.5) * 0.03 + vec2(0.0, uScroll * 0.015);
        uv += par;

        float h = smoothstep(0.0, 1.0, uv.y);
        vec3 sky = mix(uPeriwinkleC, uPeriwinkleB, h);
        sky = mix(sky, uPeriwinkleA, smoothstep(0.4, 1.0, h));

        vec2 p = (uv * 3.0) / uNoiseScale;
        float t = uTime * 0.05;
        float n = fbm(p + vec2(t, -t*0.7));
        float m = fbm(p*0.7 - vec2(t*0.6, t*0.4));
        float neb = pow(smoothstep(0.45, 1.0, n*0.6 + m*0.7), 1.6);

        vec3 tint = mix(uCool, uWarm, smoothstep(0.2, 0.9, n));
        vec3 color = sky + neb * uNebulaStrength * (tint);

        vec2 d = uv - 0.5;
        float vig = smoothstep(0.95, uVignette, dot(d,d)*1.8);
        color *= mix(1.0, 0.75, vig);

        gl_FragColor = vec4(color, 1.0);
      }
    `,
    depthTest: false,
    depthWrite: false
  });

  const quad = new THREE.Mesh(quadGeo, nebulaMat);
  scene.add(quad);

  // ---- 2) GPU star particles with twinkle ----
  const starCount = 3500;
  const pGeom = new THREE.BufferGeometry();
  const positions = new Float32Array(starCount * 3);
  const sizes = new Float32Array(starCount);
  const tints = new Float32Array(starCount * 3);

  for (let i=0;i<starCount;i++){
    positions[i*3 + 0] = (Math.random()*2-1);
    positions[i*3 + 1] = (Math.random()*2-1);
    positions[i*3 + 2] = 0;
    sizes[i] = Math.pow(Math.random(), 2.0) * 2.2 + 0.6;
    const cool = new THREE.Color('#dff2ff');
    const warm = new THREE.Color('#fff0ff');
    const mixr = Math.random();
    const mixed = cool.clone().lerp(warm, mixr);
    tints[i*3+0]=mixed.r; tints[i*3+1]=mixed.g; tints[i*3+2]=mixed.b;
  }
  pGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  pGeom.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  pGeom.setAttribute('tint', new THREE.BufferAttribute(tints, 3));

  const starMat = new THREE.ShaderMaterial({
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    uniforms: {
      uTime: { value: 0 },
      uParallax: { value: new THREE.Vector2(0,0) },
      uScale: { value: window.devicePixelRatio }
    },
    vertexShader: `
      attribute float size;
      attribute vec3 tint;
      varying vec3 vTint;
      uniform vec2 uParallax;
      void main(){
        vTint = tint;
        vec3 p = position;
        p.xy += uParallax * 0.12;
        gl_Position = vec4(p, 1.0);
        gl_PointSize = size * 1.8 * (1.0 + (p.y+1.0)*0.15);
      }
    `,
    fragmentShader: `
      precision highp float;
      uniform float uTime;
      varying vec3 vTint;
      void main(){
        vec2 uv = gl_PointCoord - 0.5;
        float r = length(uv);
        float core = smoothstep(0.5, 0.0, r);
        float tw = 0.65 + 0.35 * sin(uTime*3.0 + (uv.x+uv.y)*40.0);
        vec3 col = vTint * (1.2*tw);
        gl_FragColor = vec4(col, core);
      }
    `
  });

  const points = new THREE.Points(pGeom, starMat);
  scene.add(points);

  // ---- 3) Post-processing Bloom ----
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  const bloom = new BloomEffect({
    intensity: 0.6,
    luminanceThreshold: 0.0,
    luminanceSmoothing: 0.5,
    radius: 0.9
  });
  const effectPass = new EffectPass(camera, bloom);
  composer.addPass(renderPass);
  composer.addPass(effectPass);

  function onResize(){
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener('resize', onResize);

  const mouse = new THREE.Vector2(0.5, 0.5);
  window.addEventListener('pointermove', (e)=>{
    mouse.x = e.clientX / window.innerWidth;
    mouse.y = e.clientY / window.innerHeight;
  }, { passive: true });

  let scrollY = 0;
  window.addEventListener('scroll', ()=>{
    scrollY = window.scrollY / Math.max(1, document.body.scrollHeight - window.innerHeight);
  }, { passive: true });

  const clock = new THREE.Clock();
  function tick(){
    const t = clock.getElapsedTime();
    nebulaMat.uniforms.uTime.value = t;
    nebulaMat.uniforms.uMouse.value.set(mouse.x, 1.0 - mouse.y);
    nebulaMat.uniforms.uScroll.value = scrollY;

    starMat.uniforms.uTime.value = t;
    starMat.uniforms.uParallax.value.set((mouse.x-0.5), (0.5-mouse.y) + scrollY*0.35);

    if (prefersReduced){
      composer.render();
      return;
    }

    composer.render();
    requestAnimationFrame(tick);
  }

  if (prefersReduced) composer.render(); else tick();
</script>