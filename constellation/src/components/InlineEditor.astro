---
export interface Props {
  filePath: string;
  content: string;
}

const { filePath, content } = Astro.props;
---

<div id="inline-editor-container" class="inline-editor-wrapper">
  <!-- Edit Button -->
  <button
    id="edit-btn"
    class="edit-button"
    title="Edit this page"
    data-file-path={filePath}
  >
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
      <path d="m18.5 2.5 a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
    </svg>
    Edit
  </button>

  <!-- Editor Modal -->
  <div id="editor-modal" class="editor-modal hidden">
    <div class="editor-content">
      <div class="editor-header">
        <h3>Editing: {filePath}</h3>
        <div class="editor-actions">
          <button id="save-btn" class="btn-primary">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="m9 12 2 2 4-4"></path>
              <path d="M21 12c.552 0 1-.448 1-1V7a1 1 0 0 0-.293-.707l-3-3A1 1 0 0 0 18 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4c0-.552-.448-1-1-1"></path>
            </svg>
            Save
          </button>
          <button id="cancel-btn" class="btn-secondary">Cancel</button>
        </div>
      </div>

      <div class="editor-body">
        <!-- Monaco Editor will be mounted here -->
        <div id="monaco-editor" class="monaco-container"></div>
      </div>

      <div class="editor-footer">
        <div class="status-bar">
          <span id="auth-status">Checking authentication...</span>
          <span id="save-status"></span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Monaco Editor CDN -->
<script is:inline>
  window.monacoContent = `{content}`;
</script>

<style>
  .inline-editor-wrapper {
    position: relative;
  }

  .edit-button {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    background: var(--sl-color-accent);
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
    font-weight: 500;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease;
  }

  .edit-button:hover {
    background: var(--sl-color-accent-high);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  .edit-button.hidden {
    display: none;
  }

  .editor-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 2000;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  .editor-modal.hidden {
    display: none;
  }

  .editor-content {
    background: var(--sl-color-bg);
    border: 1px solid var(--sl-color-gray-5);
    border-radius: 8px;
    width: 90vw;
    max-width: 1200px;
    height: 80vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  }

  .editor-header {
    padding: 16px 20px;
    border-bottom: 1px solid var(--sl-color-gray-5);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--sl-color-bg-nav);
  }

  .editor-header h3 {
    margin: 0;
    font-size: 16px;
    color: var(--sl-color-white);
  }

  .editor-actions {
    display: flex;
    gap: 8px;
  }

  .btn-primary, .btn-secondary {
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s ease;
  }

  .btn-primary {
    background: var(--sl-color-accent);
    color: white;
  }

  .btn-primary:hover {
    background: var(--sl-color-accent-high);
  }

  .btn-primary:disabled {
    background: var(--sl-color-gray-4);
    cursor: not-allowed;
  }

  .btn-secondary {
    background: var(--sl-color-gray-5);
    color: var(--sl-color-white);
  }

  .btn-secondary:hover {
    background: var(--sl-color-gray-4);
  }

  .editor-body {
    flex: 1;
    display: flex;
    padding: 0;
  }

  .monaco-container {
    width: 100%;
    height: 100%;
    border: 1px solid var(--sl-color-gray-5);
  }

  .editor-footer {
    padding: 12px 20px;
    border-top: 1px solid var(--sl-color-gray-5);
    background: var(--sl-color-bg-nav);
  }

  .status-bar {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: var(--sl-color-gray-3);
  }

  #auth-status.authenticated {
    color: var(--sl-color-green);
  }

  #auth-status.unauthenticated {
    color: var(--sl-color-red);
  }

  #save-status.saving {
    color: var(--sl-color-orange);
  }

  #save-status.saved {
    color: var(--sl-color-green);
  }

  #save-status.error {
    color: var(--sl-color-red);
  }
</style>

<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
<script>
  class InlineEditor {
    private editBtn: HTMLButtonElement;
    private modal: HTMLElement;
    private monacoContainer: HTMLElement;
    private saveBtn: HTMLButtonElement;
    private cancelBtn: HTMLButtonElement;
    private authStatus: HTMLElement;
    private saveStatus: HTMLElement;
    private filePath: string;
    private originalContent: string;
    private isAuthenticated = false;
    private editor: any = null;

    constructor() {
      this.editBtn = document.getElementById('edit-btn') as HTMLButtonElement;
      this.modal = document.getElementById('editor-modal') as HTMLElement;
      this.monacoContainer = document.getElementById('monaco-editor') as HTMLElement;
      this.saveBtn = document.getElementById('save-btn') as HTMLButtonElement;
      this.cancelBtn = document.getElementById('cancel-btn') as HTMLButtonElement;
      this.authStatus = document.getElementById('auth-status') as HTMLElement;
      this.saveStatus = document.getElementById('save-status') as HTMLElement;

      this.filePath = this.editBtn.dataset.filePath || '';
      this.originalContent = (window as any).monacoContent || '';

      this.init();
    }

    private async init() {
      // Check authentication status
      await this.checkAuth();

      // Set up event listeners
      this.editBtn.addEventListener('click', () => this.openEditor());
      this.cancelBtn.addEventListener('click', () => this.closeEditor());
      this.saveBtn.addEventListener('click', () => this.saveContent());

      // Close modal on backdrop click
      this.modal.addEventListener('click', (e) => {
        if (e.target === this.modal) {
          this.closeEditor();
        }
      });

      // Close modal on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !this.modal.classList.contains('hidden')) {
          this.closeEditor();
        }
      });
    }

    private async checkAuth() {
      try {
        const response = await fetch('/api/auth-check');
        const data = await response.json();

        this.isAuthenticated = data.authenticated;

        if (this.isAuthenticated) {
          this.authStatus.textContent = `Authenticated as ${data.email}`;
          this.authStatus.className = 'authenticated';
          this.editBtn.classList.remove('hidden');
        } else {
          this.authStatus.textContent = 'Not authenticated - editing disabled';
          this.authStatus.className = 'unauthenticated';
          this.editBtn.classList.add('hidden');
        }
      } catch (error) {
        console.error('Auth check failed:', error);
        this.authStatus.textContent = 'Authentication check failed';
        this.authStatus.className = 'unauthenticated';
        this.editBtn.classList.add('hidden');
      }
    }

    private async openEditor() {
      if (!this.isAuthenticated) {
        alert('Please authenticate via Cloudflare Access to edit documents.');
        return;
      }

      this.modal.classList.remove('hidden');

      // Fetch content if not available
      if (!this.originalContent) {
        await this.fetchContent();
      }

      // Initialize Monaco Editor if not already done
      if (!this.editor) {
        await this.initMonaco();
      }
    }

    private async fetchContent() {
      try {
        this.updateSaveStatus('Loading content...', 'saving');

        const response = await fetch(`/api/get-doc?filePath=${encodeURIComponent(this.filePath)}`);
        const data = await response.json();

        if (response.ok) {
          this.originalContent = data.content;
          this.updateSaveStatus('', '');
        } else {
          this.updateSaveStatus(`Error loading: ${data.message}`, 'error');
        }
      } catch (error) {
        console.error('Error fetching content:', error);
        this.updateSaveStatus('Error loading content', 'error');
      }
    }

    private async initMonaco() {
      return new Promise((resolve) => {
        (window as any).require.config({
          paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' }
        });

        (window as any).require(['vs/editor/editor.main'], () => {
          this.editor = (window as any).monaco.editor.create(this.monacoContainer, {
            value: this.originalContent,
            language: 'markdown',
            theme: 'vs-dark',
            automaticLayout: true,
            wordWrap: 'on',
            minimap: { enabled: false },
            lineNumbers: 'on',
            renderWhitespace: 'selection',
            fontFamily: 'Monaco, Menlo, "Ubuntu Mono", monospace',
            fontSize: 14,
            tabSize: 2,
            insertSpaces: true,
            scrollBeyondLastLine: false,
            roundedSelection: false,
            readOnly: false,
            folding: true,
            foldingHighlight: false,
            showFoldingControls: 'mouseover',
            matchBrackets: 'always',
            glyphMargin: true,
            useTabStops: false,
            mouseWheelZoom: true,
          });

          // Add Ctrl/Cmd + S keybinding
          this.editor.addCommand((window as any).monaco.KeyMod.CtrlCmd | (window as any).monaco.KeyCode.KeyS, () => {
            this.saveContent();
          });

          resolve(this.editor);
        });
      });
    }

    private closeEditor() {
      if (this.editor) {
        // Check for unsaved changes
        const currentContent = this.editor.getValue();
        if (currentContent !== this.originalContent) {
          if (!confirm('You have unsaved changes. Are you sure you want to close the editor?')) {
            return;
          }
        }

        // Reset editor content
        this.editor.setValue(this.originalContent);
      }

      this.modal.classList.add('hidden');
      this.saveStatus.textContent = '';
    }

    private async saveContent() {
      if (!this.isAuthenticated) {
        this.updateSaveStatus('Not authenticated', 'error');
        return;
      }

      if (!this.editor) {
        this.updateSaveStatus('Editor not initialized', 'error');
        return;
      }

      const content = this.editor.getValue();

      this.saveBtn.disabled = true;
      this.updateSaveStatus('Saving...', 'saving');

      try {
        const response = await fetch('/api/save-doc', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filePath: this.filePath,
            content: content
          })
        });

        const result = await response.json();

        if (response.ok) {
          this.originalContent = content;
          this.updateSaveStatus('Saved successfully!', 'saved');

          // Auto-hide success message after 3 seconds
          setTimeout(() => {
            this.saveStatus.textContent = '';
          }, 3000);

          // Optionally reload the page to show changes
          // setTimeout(() => window.location.reload(), 1000);
        } else {
          this.updateSaveStatus(`Save failed: ${result.message}`, 'error');
        }
      } catch (error) {
        console.error('Save error:', error);
        this.updateSaveStatus('Save failed: Network error', 'error');
      } finally {
        this.saveBtn.disabled = false;
      }
    }

    private updateSaveStatus(message: string, type: string) {
      this.saveStatus.textContent = message;
      this.saveStatus.className = type;
    }
  }

  // Initialize the editor when the page loads
  document.addEventListener('DOMContentLoaded', () => {
    new InlineEditor();
  });
</script>