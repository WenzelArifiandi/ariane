name: "üöÄ Deploy Zitadel to Oracle Cloud"

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      force:
        description: "Force deploy even if no changes detected"
        required: false
        default: false
        type: boolean
      ssh_user:
        description: "Override SSH user (optional; default ubuntu; fallback to opc if unset and ubuntu fails)"
        required: false
        type: string
        default: ""
      ssh_port:
        description: "Override SSH port (optional; default 22)"
        required: false
        type: string
        default: ""

permissions:
  contents: write
  security-events: write
  actions: read
  pull-requests: write

jobs:
  deploy:
    name: "üèóÔ∏è Deploy to Production"
    runs-on: ubuntu-latest

    steps:
      - name: "üì• Checkout Code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: "üîç Detect Changes"
        id: changes
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_FORCE: ${{ github.event.inputs.force }}
          GITHUB_REF: ${{ github.ref }}
          EVENT_BEFORE: ${{ github.event.before }}
        run: |
          # Determine whether to deploy using git-based and Oracle server state comparison
          echo "üîç Enhanced deployment change detection"
          echo "======================================"

          CURRENT_COMMIT=$(git rev-parse HEAD)
          echo "üìç Current commit: $CURRENT_COMMIT"

          # 1) If manually dispatched with force=true, always deploy
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ "$INPUT_FORCE" = "true" ]; then
            echo "zitadel_changed=true" >> $GITHUB_OUTPUT
            echo "üöÄ Manual dispatch with force=true: will deploy"
            exit 0
          fi

          # 2) Check git changes first (this is always reliable)
          echo ""
          echo "üîç Checking git changes since last commit..."
          git fetch --no-tags --depth=10 origin "$GITHUB_REF"

          BASE="$EVENT_BEFORE"
          if [ -z "$BASE" ] || ! git cat-file -e "$BASE^{commit}" 2>/dev/null; then
            BASE="HEAD~1"
          fi

          CHANGED_FILES=$(git diff --name-only "$BASE"...HEAD -- zitadel/ || true)
          echo "üìÑ Git changes in zitadel/ since $BASE:"
          if [ -n "$CHANGED_FILES" ]; then
            echo "$CHANGED_FILES"
            GIT_HAS_CHANGES=true
          else
            echo "  (no changes)"
            GIT_HAS_CHANGES=false
          fi

          # 3) Store state for Oracle comparison later (after SSH setup)
          echo "git_has_changes=$GIT_HAS_CHANGES" >> $GITHUB_OUTPUT
          echo "current_commit=$CURRENT_COMMIT" >> $GITHUB_OUTPUT

          # For now, deploy if git has changes (Oracle comparison happens in SSH setup step)
          if [ "$GIT_HAS_CHANGES" = "true" ]; then
            echo "zitadel_changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Git changes detected - proceeding with deployment pipeline"
          else
            echo "zitadel_changed=maybe" >> $GITHUB_OUTPUT
            echo "üîç No git changes - will check Oracle server state next"
          fi

      - name: "üîß Setup SSH"
        if: steps.changes.outputs.zitadel_changed == 'true' || steps.changes.outputs.zitadel_changed == 'maybe'
        env:
          ORA_HOST: ${{ secrets.ORACLE_HOST }}
          ORA_SSH_KEY: ${{ secrets.ORACLE_SSH_KEY }}
          INPUT_SSH_USER: ${{ inputs.ssh_user }}
          INPUT_SSH_PORT: ${{ inputs.ssh_port }}
        run: |
          # Resolve SSH host/user/port with defaults
          SSH_HOST="${ORA_HOST}"
          SSH_USER="${INPUT_SSH_USER}"
          SSH_PORT="${INPUT_SSH_PORT}"
          [ -z "$SSH_USER" ] && SSH_USER="ubuntu"
          [ -z "$SSH_PORT" ] && SSH_PORT="22"

          mkdir -p ~/.ssh
          KEY_TMP=~/.ssh/oracle_key.tmp
          KEY_PATH=~/.ssh/oracle_key

          # Write SSH key and normalize formats
          # Supports: PEM with actual newlines, PEM with literal \n, base64-encoded PEM, CRLF endings
          printf '%s' "${ORA_SSH_KEY}" > "$KEY_TMP"
          if grep -q '\\n' "$KEY_TMP"; then
            # Convert literal \n sequences into real newlines and strip any \r
            sed -e 's/\\r//g' -e 's/\\n/\n/g' "$KEY_TMP" > "$KEY_PATH"
          else
            # Remove CRLF if present
            tr -d '\r' < "$KEY_TMP" > "$KEY_PATH"
          fi
          rm -f "$KEY_TMP"

          # If the key doesn't look like PEM, attempt base64 decode (supports base64-encoded secrets)
          if ! head -n1 "$KEY_PATH" | grep -q "BEGIN .*PRIVATE KEY"; then
            if base64 -d "$KEY_PATH" > "$KEY_PATH.dec" 2>/dev/null; then
              mv "$KEY_PATH.dec" "$KEY_PATH"
            fi
          fi
          chmod 600 "$KEY_PATH"

          # Enhanced SSH key validation and diagnostics
          echo "üîç SSH Key Diagnostics:"
          echo "Key file size: $(stat -c%s "$KEY_PATH" 2>/dev/null || stat -f%z "$KEY_PATH") bytes"
          echo "First line: $(head -n1 "$KEY_PATH")"
          echo "Last line: $(tail -n1 "$KEY_PATH")"
          echo "Total lines: $(wc -l < "$KEY_PATH")"

          # Test key format
          if ssh-keygen -y -f "$KEY_PATH" >/dev/null 2>&1; then
            echo "‚úÖ SSH private key format is valid"
            PUB_KEY=$(ssh-keygen -y -f "$KEY_PATH")
            echo "üìã Public key fingerprint: $(echo "$PUB_KEY" | ssh-keygen -lf -)"
          else
            echo "‚ùå SSH private key validation failed"
            echo "üîç Detailed ssh-keygen error:"
            ssh-keygen -y -f "$KEY_PATH" 2>&1 || true
            echo ""
            echo "üîß Troubleshooting suggestions:"
            echo "1. Ensure ORACLE_SSH_KEY contains complete private key with headers/footers"
            echo "2. Verify key is not password-protected"
            echo "3. Check if key was copied correctly (no missing characters)"
            echo "4. Ensure the key format matches what was generated (RSA, ED25519, etc.)"
          fi

          # Add known hosts (respect port)
          ssh-keyscan -p "$SSH_PORT" -H "$SSH_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

          # Make SSH options available to all subsequent steps
          echo "SSH_HOST=$SSH_HOST" >> "$GITHUB_ENV"
          echo "SSH_USER=$SSH_USER" >> "$GITHUB_ENV"
          echo "SSH_PORT=$SSH_PORT" >> "$GITHUB_ENV"
          echo "SSH_OPTS=-i ~/.ssh/oracle_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o BatchMode=yes -o UserKnownHostsFile=~/.ssh/known_hosts -o ConnectTimeout=20" >> "$GITHUB_ENV"

          # Compute dynamic remote paths based on SSH_USER
          echo "DEPLOYMENT_PATH=/home/$SSH_USER/zitadel" >> "$GITHUB_ENV"
          echo "BACKUP_PATH=/home/$SSH_USER/zitadel-backups" >> "$GITHUB_ENV"

          # Test SSH connection with detailed diagnostics
          set +e
          echo "üîó Testing SSH connection to $SSH_USER@$SSH_HOST:$SSH_PORT ..."
          echo "SSH options: $SSH_OPTS"

          # Test connection with verbose output for debugging
          echo "üîç Detailed SSH connection attempt:"
          ssh -p "$SSH_PORT" $SSH_OPTS -v "$SSH_USER@$SSH_HOST" "echo 'SSH connection successful'" 2>&1 | head -20
          SSH_STATUS=$?

          if [ "$SSH_STATUS" -ne 0 ] && [ -z "${INPUT_SSH_USER}" ]; then
            echo ""
            echo "‚ö†Ô∏è SSH failed for user 'ubuntu' (exit code: $SSH_STATUS). Trying fallback user 'opc'..."
            SSH_USER="opc"
            echo "SSH_USER=$SSH_USER" >> "$GITHUB_ENV"
            # Update paths for opc
            echo "DEPLOYMENT_PATH=/home/$SSH_USER/zitadel" >> "$GITHUB_ENV"
            echo "BACKUP_PATH=/home/$SSH_USER/zitadel-backups" >> "$GITHUB_ENV"

            echo "üîç Detailed SSH connection attempt (opc):"
            ssh -p "$SSH_PORT" $SSH_OPTS -v "$SSH_USER@$SSH_HOST" "echo 'SSH connection successful'" 2>&1 | head -20
            SSH_STATUS=$?
          fi
          set -e

          if [ "$SSH_STATUS" -ne 0 ]; then
            echo ""
            echo "‚ùå SSH connection failed for both ubuntu and opc users (final exit code: $SSH_STATUS)"
            echo ""
            echo "üîß Common solutions:"
            echo "1. Verify ORACLE_SSH_KEY secret contains the correct private key"
            echo "2. Check that the corresponding public key is in ~/.ssh/authorized_keys on the server"
            echo "3. Ensure the server allows SSH key authentication (PubkeyAuthentication yes)"
            echo "4. Verify the server is accessible on port $SSH_PORT"
            echo "5. Check Oracle Cloud security rules allow SSH (port $SSH_PORT) from GitHub Actions IPs"
            echo ""
            echo "üîç To debug manually:"
            echo "  ssh-keygen -y -f your_private_key_file  # Extract public key"
            echo "  ssh -v $SSH_USER@$SSH_HOST  # Test connection with verbose output"
            exit 1
          fi

          # Oracle state comparison (now that SSH is working)
          if [ "${{ steps.changes.outputs.zitadel_changed }}" = "maybe" ]; then
            echo ""
            echo "üîç Checking deployment state on Oracle server..."

            CURRENT_COMMIT="${{ steps.changes.outputs.current_commit }}"
            DEPLOYMENT_STATE_FILE="/home/$SSH_USER/zitadel/.deployment_state"

            set +e
            DEPLOYED_COMMIT=$(ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "if [ -f \"$DEPLOYMENT_STATE_FILE\" ]; then cat \"$DEPLOYMENT_STATE_FILE\"; else echo 'NONE'; fi" 2>/dev/null | tr -d '\r\n' || echo "FAILED")
            set -e

            if [ "$DEPLOYED_COMMIT" = "FAILED" ]; then
              echo "‚ö†Ô∏è Could not read Oracle deployment state - will proceed with deployment"
              FINAL_DECISION="deploy"
              DECISION_REASON="Cannot verify Oracle state"
            elif [ "$DEPLOYED_COMMIT" = "NONE" ]; then
              echo "üì≠ No previous deployment found on Oracle"
              FINAL_DECISION="deploy"
              DECISION_REASON="Oracle server has never been deployed to"
            elif [ "$DEPLOYED_COMMIT" = "$CURRENT_COMMIT" ]; then
              echo "‚úÖ Oracle server is up-to-date with current commit"
              FINAL_DECISION="skip"
              DECISION_REASON="Oracle matches current commit and no git changes"
            else
              echo "üîÑ Oracle server has commit $DEPLOYED_COMMIT but current is $CURRENT_COMMIT"
              FINAL_DECISION="deploy"
              DECISION_REASON="Oracle server is out of sync with current commit"
            fi

            echo "üìã Final Decision: $DECISION_REASON"

            # Update the deployment decision
            if [ "$FINAL_DECISION" = "deploy" ]; then
              echo "FINAL_DEPLOY=true" >> $GITHUB_ENV
              echo "‚úÖ Will proceed with deployment"
            else
              echo "FINAL_DEPLOY=false" >> $GITHUB_ENV
              echo "‚è≠Ô∏è Skipping deployment"
            fi
          else
            echo "FINAL_DEPLOY=true" >> $GITHUB_ENV
            echo "‚úÖ Git changes detected - proceeding with deployment"
          fi

      - name: "üìÅ Ensure Remote Deployment Directory"
        if: env.FINAL_DEPLOY == 'true'
        run: |
          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "
            sudo mkdir -p $DEPLOYMENT_PATH $BACKUP_PATH && sudo chown -R $SSH_USER:$SSH_USER $DEPLOYMENT_PATH $BACKUP_PATH
          "

      - name: "üè• Health Check - Pre Deployment"
        if: env.FINAL_DEPLOY == 'true'
        run: |
          echo "üîç Checking Zitadel health before deployment..."
          response=$(curl -s -o /dev/null -w "%{http_code}" https://auth.wenzelarifiandi.com/.well-known/openid-configuration || echo "000")
          if [ "$response" != "200" ]; then
            echo "‚ö†Ô∏è Zitadel is not healthy (HTTP $response), but proceeding with deployment"
          else
            echo "‚úÖ Zitadel is healthy (HTTP $response)"
          fi

      - name: "üíæ Create Backup"
        if: env.FINAL_DEPLOY == 'true'
        run: |
          echo "üì¶ Creating backup of current deployment..."
          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "
            # Select docker compose command
            if command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else DC='docker compose'; fi

            # Create backup directory with timestamp
            BACKUP_DIR=\"$BACKUP_PATH/backup-$(date +%Y%m%d-%H%M%S)\"
            mkdir -p \"$BACKUP_DIR\"

            # Backup configuration files
            cp -r $DEPLOYMENT_PATH/* \"$BACKUP_DIR/\" 2>/dev/null || true

            # Backup database
            cd $DEPLOYMENT_PATH
            \$DC exec -T db pg_dump -U postgres zitadel > \"$BACKUP_DIR/database.sql\" 2>/dev/null || true

            # Keep only last 5 backups
            ls -dt $BACKUP_PATH/backup-* | tail -n +6 | xargs rm -rf 2>/dev/null || true

            echo \"‚úÖ Backup created at $BACKUP_DIR\"
          "

      - name: "üöÄ Deploy Configuration"
        if: env.FINAL_DEPLOY == 'true'
        run: |
          echo "üöÄ Deploying new configuration..."

          # Copy new configuration files
          scp -P "$SSH_PORT" $SSH_OPTS -r zitadel/* "$SSH_USER@$SSH_HOST:$DEPLOYMENT_PATH/"

          # Execute deployment on remote server
          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "
            cd $DEPLOYMENT_PATH

            # Select docker compose command
            if command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else DC='docker compose'; fi

            echo \"üìã Current status:\"
            \$DC ps

            echo \"üîÑ Performing rolling update...\"

            # Pull latest images if needed
            \$DC pull

            # Restart services with zero downtime
            \$DC up -d --remove-orphans

            echo \"‚è≥ Waiting for services to be ready...\"
            sleep 30

            echo \"üìä New status:\"
            \$DC ps
          "

      - name: "üè• Health Check - Post Deployment"
        if: env.FINAL_DEPLOY == 'true'
        run: |
          echo "üîç Checking Zitadel health after deployment..."

          # Wait a bit more for services to stabilize
          sleep 30

          # Check OIDC endpoint
          max_attempts=10
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            echo "üîç Health check attempt $attempt/$max_attempts..."

            response=$(curl -s -o /dev/null -w "%{http_code}" https://auth.wenzelarifiandi.com/.well-known/openid-configuration || echo "000")

            if [ "$response" = "200" ]; then
              echo "‚úÖ Zitadel is healthy! Deployment successful."

              # Test console access
              console_response=$(curl -s -o /dev/null -w "%{http_code}" https://auth.wenzelarifiandi.com/ui/console || echo "000")
              if [ "$console_response" = "200" ]; then
                echo "‚úÖ Console is accessible"
              else
                echo "‚ö†Ô∏è Console returned HTTP $console_response"
              fi

              # Record successful deployment state
              DEPLOYMENT_SUCCESS=true
              exit 0
            fi

            echo "‚ùå Health check failed (HTTP $response), retrying in 10 seconds..."
            sleep 10
            attempt=$((attempt + 1))
          done

          echo "üí• Health check failed after $max_attempts attempts"
          exit 1

      - name: "üìù Record Deployment State"
        if: env.FINAL_DEPLOY == 'true'
        run: |
          echo "üìù Recording deployment state on Oracle server..."

          CURRENT_COMMIT=$(git rev-parse HEAD)
          DEPLOYMENT_STATE_FILE="/home/$SSH_USER/zitadel/.deployment_state"
          DEPLOYMENT_LOG_FILE="/home/$SSH_USER/zitadel/.deployment_log"

          # Create deployment record with commit hash, timestamp, and workflow info
          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "
            # Ensure zitadel directory exists
            mkdir -p /home/$SSH_USER/zitadel

            # Record current deployment state
            echo '$CURRENT_COMMIT' > '$DEPLOYMENT_STATE_FILE'

            # Append to deployment log for history
            echo \"\$(date -Iseconds) - Deployed commit $CURRENT_COMMIT (GitHub Actions: \${{ github.run_id }})\" >> '$DEPLOYMENT_LOG_FILE'

            # Keep only last 50 deployment log entries
            tail -n 50 '$DEPLOYMENT_LOG_FILE' > '$DEPLOYMENT_LOG_FILE.tmp' && mv '$DEPLOYMENT_LOG_FILE.tmp' '$DEPLOYMENT_LOG_FILE'

            echo '‚úÖ Deployment state recorded successfully'
            echo 'üìÑ Current state file:'
            cat '$DEPLOYMENT_STATE_FILE'
          "

      - name: "üîî Deployment Notification"
        if: always() && env.FINAL_DEPLOY == 'true'
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Deployment completed successfully!"
            echo "üåê Zitadel: https://auth.wenzelarifiandi.com"
            echo "üñ•Ô∏è Console: https://auth.wenzelarifiandi.com/ui/console"
          else
            echo "‚ùå Deployment failed!"
            echo "üîç Check the logs above for details"
            echo "üíæ Automatic backup was created before deployment"
          fi

      - name: "üÜò Rollback on Failure"
        if: failure() && steps.changes.outputs.zitadel_changed == 'true'
        env:
          ORA_SSH_KEY: ${{ secrets.ORACLE_SSH_KEY }}
        run: |
          echo "üÜò Deployment failed, initiating automatic rollback..."

          # Verify SSH key is still available
          if [ ! -f ~/.ssh/oracle_key ]; then
            echo "‚ùå SSH key not found, recreating..."
            mkdir -p ~/.ssh
            KEY_TMP=~/.ssh/oracle_key.tmp
            KEY_PATH=~/.ssh/oracle_key
            printf '%s' "${ORA_SSH_KEY}" > "$KEY_TMP"
            if grep -q '\\n' "$KEY_TMP"; then
              sed -e 's/\\r//g' -e 's/\\n/\n/g' "$KEY_TMP" > "$KEY_PATH"
            else
              tr -d '\r' < "$KEY_TMP" > "$KEY_PATH"
            fi
            rm -f "$KEY_TMP"
            if ! head -n1 "$KEY_PATH" | grep -q "BEGIN .*PRIVATE KEY"; then
              if base64 -d "$KEY_PATH" > "$KEY_PATH.dec" 2>/dev/null; then
                mv "$KEY_PATH.dec" "$KEY_PATH"
              fi
            fi
            chmod 600 "$KEY_PATH"
          fi

          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "
            cd $DEPLOYMENT_PATH

            # Select docker compose command
            if command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else DC='docker compose'; fi

            # Get latest backup
            LATEST_BACKUP=\$(ls -dt $BACKUP_PATH/backup-* | head -n 1)

            if [ -d \"$LATEST_BACKUP\" ]; then
              echo \"üì¶ Rolling back to: $LATEST_BACKUP\"

              # Stop services
              \$DC down

              # Restore configuration
              cp -r \"$LATEST_BACKUP\"/* ./

              # Restore database if backup exists
              if [ -f \"$LATEST_BACKUP/database.sql\" ]; then
                echo \"üóÑÔ∏è Restoring database...\"
                \$DC up -d db
                sleep 20
                \$DC exec -T db psql -U postgres -c 'DROP DATABASE IF EXISTS zitadel;'
                \$DC exec -T db psql -U postgres -c 'CREATE DATABASE zitadel;'
                \$DC exec -T db psql -U postgres zitadel < \"$LATEST_BACKUP/database.sql\"
              fi

              # Start all services
              \$DC up -d

              echo \"‚úÖ Rollback completed\"
            else
              echo \"‚ùå No backup found for rollback\"
            fi
          "

  security-scan:
    name: "üîí Security Scan & Vulnerability Check"
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - name: "üì• Checkout Code"
        uses: actions/checkout@v4

      - name: "üîß Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"
          cache-dependency-path: |
            site/package-lock.json
            studio/package-lock.json

      - name: "üîç Security Audit - Site"
        run: |
          cd site
          echo "üîç Running security audit for site dependencies..."
          npm audit --audit-level=moderate || {
            echo "‚ùå Security vulnerabilities found in site dependencies"
            echo "üîß Attempting to fix automatically..."
            npm audit fix || npm audit fix --force || true
          }

      - name: "üîç Security Audit - Studio"
        run: |
          cd studio
          echo "üîç Running security audit for studio dependencies..."
          npm audit --audit-level=moderate || {
            echo "‚ùå Security vulnerabilities found in studio dependencies"
            echo "üîß Attempting to fix automatically..."
            npm audit fix || npm audit fix --force || true
          }

      - name: "üîç Run Trivy Security Scan"
        uses: aquasecurity/trivy-action@915b19bbe73b92a6cf82a1bc12b087c9a19a5fe2 # v0.28.0
        with:
          scan-type: "fs"
          scan-ref: "zitadel/"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH,MEDIUM"
          # Do not fail the job on findings; report via SARIF instead
          exit-code: "0"
          # Reduce noise from unresolved upstream issues
          ignore-unfixed: true

      - name: "üìä Upload Trivy Results"
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: "üîê Check for Secrets"
        run: |
          echo "üîç Scanning for potential secrets..."

          # Check for common secret patterns
          if grep -r -i "password\|secret\|key\|token" zitadel/ --exclude-dir=node_modules --exclude="*.md" | grep -v "ZITADEL_MASTERKEY" | grep -v "example"; then
            echo "‚ö†Ô∏è Potential secrets found in Zitadel configuration"
            echo "Please review the above matches"
          else
            echo "‚úÖ No obvious secrets detected"
          fi

      - name: "üíæ Commit Security Fixes"
        if: success()
        run: |
          git config --local user.email "security-scan@github.com"
          git config --local user.name "Security Scanner"

          # Only consider tracked files for changes (avoid untracked scan artifacts like .cache/*.sarif)
          CHANGED=$(git diff --name-only -- site/package-lock.json site/package.json studio/package-lock.json studio/package.json || true)

          if [ -z "$CHANGED" ]; then
            echo "‚ÑπÔ∏è No security fixes needed (no tracked package files changed)"
            exit 0
          fi

          # Stage only the intended files
          git add site/package*.json studio/package*.json || true

          # If nothing ended up staged, skip committing to avoid 'nothing to commit' failures
          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è No staged changes after audit fixes; skipping commit"
            exit 0
          fi

          git commit -m "security: auto-fix vulnerabilities during deployment scan

          üîç Automated security fixes applied during deployment:
          - Updated dependencies to resolve vulnerabilities
          - Applied npm audit fixes

          ü§ñ Applied by deployment security scan
          üöÄ Generated with [Claude Code](https://claude.ai/code)

          Co-Authored-By: Security Scanner <security-scan@github.com>"
          echo "‚úÖ Security fixes committed locally; opening a pull request"

      - name: "üì¨ Open PR for Security Fixes"
        if: success()
        uses: peter-evans/create-pull-request@271a8d0340265f705b14b6d32b9829c1cb33d45e # v7.0.8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ci/security-fixes/${{ github.run_id }}
          title: "security: auto-fix vulnerabilities during deployment scan"
          commit-message: |
            security: auto-fix vulnerabilities during deployment scan

            üîç Automated security fixes applied during deployment:
            - Updated dependencies to resolve vulnerabilities
            - Applied npm audit fixes

            ü§ñ Applied by deployment security scan
          body: |
            This PR contains automated security fixes generated by the deployment security scan.

            - Updated dependencies to resolve vulnerabilities
            - Applied npm audit fixes

            Please review and merge to apply the fixes to `main` (branch protections prevent direct pushes).
          labels: |
            security
            automated-fix
          delete-branch: true
