name: üöÄ Deploy Zitadel to Oracle Cloud

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force:
        description: "Force deploy even if no changes detected"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  security-events: write
  actions: read

env:
  DEPLOYMENT_PATH: /home/ubuntu/zitadel
  BACKUP_PATH: /home/ubuntu/zitadel-backups

jobs:
  deploy:
    name: üèóÔ∏è Deploy to Production
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Detect Changes
        id: changes
        run: |
          # Determine whether to deploy
          # 1) If manually dispatched with force=true, always deploy
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force }}" = "true" ]; then
            echo "zitadel_changed=true" >> $GITHUB_OUTPUT
            echo "üìù Manual dispatch with force=true: will deploy"
            exit 0
          fi

          # 2) For push events, check for changes under zitadel/ between the previous and current commit
          # Ensure we have sufficient history
          git fetch --no-tags --depth=2 origin ${{ github.ref }}

          BASE="${{ github.event.before }}"
          if [ -z "$BASE" ] || ! git cat-file -e "$BASE^{commit}" 2>/dev/null; then
            BASE="HEAD~1"
          fi

          if git diff --name-only "$BASE"...HEAD | grep -q "^zitadel/"; then
            echo "zitadel_changed=true" >> $GITHUB_OUTPUT
            echo "üìù Zitadel configuration changes detected"
          else
            echo "zitadel_changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No Zitadel changes detected"
          fi

      - name: üîß Setup SSH
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          mkdir -p ~/.ssh
          KEY_TMP=~/.ssh/oracle_key.tmp
          KEY_PATH=~/.ssh/oracle_key

          # Write SSH key and normalize formats
          # Supports: PEM with actual newlines, PEM with literal \n, base64-encoded PEM, CRLF endings
          printf '%s' "${{ secrets.ORACLE_SSH_KEY }}" > "$KEY_TMP"
          if grep -q '\\n' "$KEY_TMP"; then
            # Convert literal \n sequences into real newlines and strip any \r
            sed -e 's/\\r//g' -e 's/\\n/\n/g' "$KEY_TMP" > "$KEY_PATH"
          else
            # Remove CRLF if present
            tr -d '\r' < "$KEY_TMP" > "$KEY_PATH"
          fi
          rm -f "$KEY_TMP"

          # If the key doesn't look like PEM, attempt base64 decode (supports base64-encoded secrets)
          if ! head -n1 "$KEY_PATH" | grep -q "BEGIN .*PRIVATE KEY"; then
            if base64 -d "$KEY_PATH" > "$KEY_PATH.dec" 2>/dev/null; then
              mv "$KEY_PATH.dec" "$KEY_PATH"
            fi
          fi
          chmod 600 ~/.ssh/oracle_key

          # Verify key format
          echo "üîç Verifying SSH key format..."
          head -n1 ~/.ssh/oracle_key
          tail -n1 ~/.ssh/oracle_key

          # Validate key can be parsed by ssh-keygen
          if ! ssh-keygen -y -f ~/.ssh/oracle_key >/dev/null 2>&1; then
            echo "‚ùå SSH private key could not be parsed."
            echo "üí° Tips:"
            echo "  - Ensure the secret contains the full private key, including BEGIN/END lines"
            echo "  - If you pasted a single-line key with \\n, keep it ‚Äî we convert it automatically"
            echo "  - If the key is base64-encoded, that's supported too"
            exit 1
          fi

          # Add known hosts
          ssh-keyscan -H ${{ secrets.ORACLE_HOST }} >> ~/.ssh/known_hosts

          # Make SSH options available to all subsequent steps
          echo "SSH_OPTS=-i ~/.ssh/oracle_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o UserKnownHostsFile=~/.ssh/known_hosts -o ConnectTimeout=20" >> "$GITHUB_ENV"

          # Test SSH connection
          echo "üîó Testing SSH connection..."
          if ! ssh $SSH_OPTS ubuntu@${{ secrets.ORACLE_HOST }} "echo 'SSH connection successful'"; then
            echo "‚ùå SSH connection failed. Troubleshooting info:"
            echo "üîç Key file size: $(wc -c < ~/.ssh/oracle_key) bytes"
            echo "üîç Key permissions: $(stat -c '%a' ~/.ssh/oracle_key)"
            echo "üîç First line: $(head -n1 ~/.ssh/oracle_key)"
            echo "üîç Last line: $(tail -n1 ~/.ssh/oracle_key)"

            echo ""
            echo "üí° Common fixes:"
            echo "  1. Ensure ORACLE_SSH_KEY contains the complete private key"
            echo "  2. Check key format (should start with -----BEGIN and end with -----END)"
            echo "  3. Verify ORACLE_HOST IP is correct: ${{ secrets.ORACLE_HOST }}"
            echo "  4. Ensure Oracle Cloud security rules allow SSH from GitHub Actions IPs"

            exit 1
          fi

      - name: üìÅ Ensure Remote Deployment Directory
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          ssh $SSH_OPTS ubuntu@${{ secrets.ORACLE_HOST }} "
            sudo mkdir -p $DEPLOYMENT_PATH $BACKUP_PATH && sudo chown -R ubuntu:ubuntu $DEPLOYMENT_PATH $BACKUP_PATH
          "

      - name: üè• Health Check - Pre Deployment
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          echo "üîç Checking Zitadel health before deployment..."
          response=$(curl -s -o /dev/null -w "%{http_code}" https://auth.wenzelarifiandi.com/.well-known/openid-configuration || echo "000")
          if [ "$response" != "200" ]; then
            echo "‚ö†Ô∏è Zitadel is not healthy (HTTP $response), but proceeding with deployment"
          else
            echo "‚úÖ Zitadel is healthy (HTTP $response)"
          fi

      - name: üíæ Create Backup
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          echo "üì¶ Creating backup of current deployment..."
          ssh $SSH_OPTS ubuntu@${{ secrets.ORACLE_HOST }} "
            # Select docker compose command
            if command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else DC='docker compose'; fi

            # Create backup directory with timestamp
            BACKUP_DIR=\"$BACKUP_PATH/backup-$(date +%Y%m%d-%H%M%S)\"
            mkdir -p \"\$BACKUP_DIR\"

            # Backup configuration files
            cp -r $DEPLOYMENT_PATH/* \"\$BACKUP_DIR/\" 2>/dev/null || true

            # Backup database
            cd $DEPLOYMENT_PATH
            $DC exec -T db pg_dump -U postgres zitadel > \"$BACKUP_DIR/database.sql\" 2>/dev/null || true

            # Keep only last 5 backups
            ls -dt $BACKUP_PATH/backup-* | tail -n +6 | xargs rm -rf 2>/dev/null || true

            echo \"‚úÖ Backup created at \$BACKUP_DIR\"
          "

      - name: üöÄ Deploy Configuration
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          echo "üöÄ Deploying new configuration..."

          # Copy new configuration files
          scp $SSH_OPTS -r zitadel/* ubuntu@${{ secrets.ORACLE_HOST }}:$DEPLOYMENT_PATH/

          # Execute deployment on remote server
          ssh $SSH_OPTS ubuntu@${{ secrets.ORACLE_HOST }} "
            cd $DEPLOYMENT_PATH

            # Select docker compose command
            if command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else DC='docker compose'; fi

            echo \"üìã Current status:\"
            $DC ps

            echo \"üîÑ Performing rolling update...\"

            # Pull latest images if needed
            $DC pull

            # Restart services with zero downtime
            $DC up -d --remove-orphans

            echo \"‚è≥ Waiting for services to be ready...\"
            sleep 30

            echo \"üìä New status:\"
            $DC ps
          "

      - name: üè• Health Check - Post Deployment
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          echo "üîç Checking Zitadel health after deployment..."

          # Wait a bit more for services to stabilize
          sleep 30

          # Check OIDC endpoint
          max_attempts=10
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            echo "üîç Health check attempt $attempt/$max_attempts..."

            response=$(curl -s -o /dev/null -w "%{http_code}" https://auth.wenzelarifiandi.com/.well-known/openid-configuration || echo "000")

            if [ "$response" = "200" ]; then
              echo "‚úÖ Zitadel is healthy! Deployment successful."

              # Test console access
              console_response=$(curl -s -o /dev/null -w "%{http_code}" https://auth.wenzelarifiandi.com/ui/console || echo "000")
              if [ "$console_response" = "200" ]; then
                echo "‚úÖ Console is accessible"
              else
                echo "‚ö†Ô∏è Console returned HTTP $console_response"
              fi

              exit 0
            fi

            echo "‚ùå Health check failed (HTTP $response), retrying in 10 seconds..."
            sleep 10
            attempt=$((attempt + 1))
          done

          echo "üí• Health check failed after $max_attempts attempts"
          exit 1

      - name: üîî Deployment Notification
        if: always() && steps.changes.outputs.zitadel_changed == 'true'
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Deployment completed successfully!"
            echo "üåê Zitadel: https://auth.wenzelarifiandi.com"
            echo "üñ•Ô∏è Console: https://auth.wenzelarifiandi.com/ui/console"
          else
            echo "‚ùå Deployment failed!"
            echo "üîç Check the logs above for details"
            echo "üíæ Automatic backup was created before deployment"
          fi

      - name: üÜò Rollback on Failure
        if: failure() && steps.changes.outputs.zitadel_changed == 'true'
        run: |
          echo "üÜò Deployment failed, initiating automatic rollback..."

          # Verify SSH key is still available
          if [ ! -f ~/.ssh/oracle_key ]; then
            echo "‚ùå SSH key not found, recreating..."
            mkdir -p ~/.ssh
            KEY_TMP=~/.ssh/oracle_key.tmp
            KEY_PATH=~/.ssh/oracle_key
            printf '%s' "${{ secrets.ORACLE_SSH_KEY }}" > "$KEY_TMP"
            if grep -q '\\n' "$KEY_TMP"; then
              sed -e 's/\\r//g' -e 's/\\n/\n/g' "$KEY_TMP" > "$KEY_PATH"
            else
              tr -d '\r' < "$KEY_TMP" > "$KEY_PATH"
            fi
            rm -f "$KEY_TMP"
            if ! head -n1 "$KEY_PATH" | grep -q "BEGIN .*PRIVATE KEY"; then
              if base64 -d "$KEY_PATH" > "$KEY_PATH.dec" 2>/dev/null; then
                mv "$KEY_PATH.dec" "$KEY_PATH"
              fi
            fi
            chmod 600 "$KEY_PATH"
          fi

          ssh $SSH_OPTS ubuntu@${{ secrets.ORACLE_HOST }} "
            cd $DEPLOYMENT_PATH

            # Select docker compose command
            if command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else DC='docker compose'; fi

            # Get latest backup
            LATEST_BACKUP=\$(ls -dt $BACKUP_PATH/backup-* | head -n 1)

            if [ -d \"\$LATEST_BACKUP\" ]; then
              echo \"üì¶ Rolling back to: \$LATEST_BACKUP\"

              # Stop services
              $DC down

              # Restore configuration
              cp -r \"\$LATEST_BACKUP\"/* ./

              # Restore database if backup exists
              if [ -f \"\$LATEST_BACKUP/database.sql\" ]; then
                echo \"üóÑÔ∏è Restoring database...\"
                $DC up -d db
                sleep 20
                $DC exec -T db psql -U postgres -c 'DROP DATABASE IF EXISTS zitadel;'
                $DC exec -T db psql -U postgres -c 'CREATE DATABASE zitadel;'
                $DC exec -T db psql -U postgres zitadel < \"$LATEST_BACKUP/database.sql\"
              fi

              # Start all services
              $DC up -d

              echo \"‚úÖ Rollback completed\"
            else
              echo \"‚ùå No backup found for rollback\"
            fi
          "

  security-scan:
    name: üîí Security Scan & Vulnerability Check
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"
          cache-dependency-path: |
            site/package-lock.json
            studio/package-lock.json

      - name: üîç Security Audit - Site
        run: |
          cd site
          echo "üîç Running security audit for site dependencies..."
          npm audit --audit-level=moderate || {
            echo "‚ùå Security vulnerabilities found in site dependencies"
            echo "üîß Attempting to fix automatically..."
            npm audit fix || npm audit fix --force || true
          }

      - name: üîç Security Audit - Studio
        run: |
          cd studio
          echo "üîç Running security audit for studio dependencies..."
          npm audit --audit-level=moderate || {
            echo "‚ùå Security vulnerabilities found in studio dependencies"
            echo "üîß Attempting to fix automatically..."
            npm audit fix || npm audit fix --force || true
          }

      - name: üîç Run Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "zitadel/"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH,MEDIUM"

      - name: üìä Upload Trivy Results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: üîê Check for Secrets
        run: |
          echo "üîç Scanning for potential secrets..."

          # Check for common secret patterns
          if grep -r -i "password\|secret\|key\|token" zitadel/ --exclude-dir=node_modules --exclude="*.md" | grep -v "ZITADEL_MASTERKEY" | grep -v "example"; then
            echo "‚ö†Ô∏è Potential secrets found in Zitadel configuration"
            echo "Please review the above matches"
          else
            echo "‚úÖ No obvious secrets detected"
          fi

      - name: üíæ Commit Security Fixes
        if: success()
        run: |
          git config --local user.email "security-scan@github.com"
          git config --local user.name "Security Scanner"

          if [ -n "$(git status --porcelain)" ]; then
            git add site/package*.json studio/package*.json
            git commit -m "security: auto-fix vulnerabilities during deployment scan

            üîç Automated security fixes applied during deployment:
            - Updated dependencies to resolve vulnerabilities
            - Applied npm audit fixes

            ü§ñ Applied by deployment security scan
            üöÄ Generated with [Claude Code](https://claude.ai/code)

            Co-Authored-By: Security Scanner <security-scan@github.com>"

            git push
            echo "‚úÖ Security fixes applied and committed"
          else
            echo "‚ÑπÔ∏è No security fixes needed"
          fi
