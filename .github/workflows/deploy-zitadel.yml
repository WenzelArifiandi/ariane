name: "üöÄ Deploy Zitadel to Oracle Cloud"

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      force:
        description: "Force deploy even if no changes detected"
        required: false
        default: false
        type: boolean
      ssh_user:
        description: "Override SSH user (optional; default ubuntu; fallback to opc if unset and ubuntu fails)"
        required: false
        type: string
        default: ""
      ssh_port:
        description: "Override SSH port (optional; default 22)"
        required: false
        type: string
        default: ""

permissions:
  contents: write
  security-events: write
  actions: read

jobs:
  deploy:
    name: "üèóÔ∏è Deploy to Production"
    runs-on: ubuntu-latest

    steps:
      - name: "üì• Checkout Code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: "üîç Detect Changes"
        id: changes
        run: |
          # Determine whether to deploy
          # 1) If manually dispatched with force=true, always deploy
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force }}" = "true" ]; then
            echo "zitadel_changed=true" >> $GITHUB_OUTPUT
            echo "üìù Manual dispatch with force=true: will deploy"
            exit 0
          fi

          # 2) For push events, check for changes under zitadel/ between the previous and current commit
          # Ensure we have sufficient history
          git fetch --no-tags --depth=2 origin ${{ github.ref }}

          BASE="${{ github.event.before }}"
          if [ -z "$BASE" ] || ! git cat-file -e "$BASE^{commit}" 2>/dev/null; then
            BASE="HEAD~1"
          fi

          if git diff --name-only "$BASE"...HEAD | grep -q "^zitadel/"; then
            echo "zitadel_changed=true" >> $GITHUB_OUTPUT
            echo "üìù Zitadel configuration changes detected"
          else
            echo "zitadel_changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No Zitadel changes detected"
          fi

      - name: "üîß Setup SSH"
        if: steps.changes.outputs.zitadel_changed == 'true'
        env:
          ORA_HOST: ${{ secrets.ORACLE_HOST }}
          ORA_SSH_KEY: ${{ secrets.ORACLE_SSH_KEY }}
          INPUT_SSH_USER: ${{ inputs.ssh_user }}
          INPUT_SSH_PORT: ${{ inputs.ssh_port }}
        run: |
          # Resolve SSH host/user/port with defaults
          SSH_HOST="${ORA_HOST}"
          SSH_USER="${INPUT_SSH_USER}"
          SSH_PORT="${INPUT_SSH_PORT}"
          [ -z "$SSH_USER" ] && SSH_USER="ubuntu"
          [ -z "$SSH_PORT" ] && SSH_PORT="22"

          mkdir -p ~/.ssh
          KEY_TMP=~/.ssh/oracle_key.tmp
          KEY_PATH=~/.ssh/oracle_key

          # Write SSH key and normalize formats
          # Supports: PEM with actual newlines, PEM with literal \n, base64-encoded PEM, CRLF endings
          printf '%s' "${ORA_SSH_KEY}" > "$KEY_TMP"
          if grep -q '\\n' "$KEY_TMP"; then
            # Convert literal \n sequences into real newlines and strip any \r
            sed -e 's/\\r//g' -e 's/\\n/\n/g' "$KEY_TMP" > "$KEY_PATH"
          else
            # Remove CRLF if present
            tr -d '\r' < "$KEY_TMP" > "$KEY_PATH"
          fi
          rm -f "$KEY_TMP"

          # If the key doesn't look like PEM, attempt base64 decode (supports base64-encoded secrets)
          if ! head -n1 "$KEY_PATH" | grep -q "BEGIN .*PRIVATE KEY"; then
            if base64 -d "$KEY_PATH" > "$KEY_PATH.dec" 2>/dev/null; then
              mv "$KEY_PATH.dec" "$KEY_PATH"
            fi
          fi
          chmod 600 "$KEY_PATH"

          # Validate key can be parsed by ssh-keygen (informational)
          if ! ssh-keygen -y -f "$KEY_PATH" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è SSH private key could not be parsed by ssh-keygen; continuing to attempt connection"
          fi

          # Add known hosts (respect port)
          ssh-keyscan -p "$SSH_PORT" -H "$SSH_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

          # Make SSH options available to all subsequent steps
          echo "SSH_HOST=$SSH_HOST" >> "$GITHUB_ENV"
          echo "SSH_USER=$SSH_USER" >> "$GITHUB_ENV"
          echo "SSH_PORT=$SSH_PORT" >> "$GITHUB_ENV"
          echo "SSH_OPTS=-i ~/.ssh/oracle_key -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -o BatchMode=yes -o UserKnownHostsFile=~/.ssh/known_hosts -o ConnectTimeout=20" >> "$GITHUB_ENV"

          # Compute dynamic remote paths based on SSH_USER
          echo "DEPLOYMENT_PATH=/home/$SSH_USER/zitadel" >> "$GITHUB_ENV"
          echo "BACKUP_PATH=/home/$SSH_USER/zitadel-backups" >> "$GITHUB_ENV"

          # Test SSH connection; if explicit user not provided, try opc fallback once
          set +e
          echo "üîó Testing SSH connection to $SSH_USER@$SSH_HOST:$SSH_PORT ..."
          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "echo 'SSH connection successful'"
          SSH_STATUS=$?
          if [ "$SSH_STATUS" -ne 0 ] && [ -z "${INPUT_SSH_USER}" ]; then
            echo "‚ö†Ô∏è SSH failed for user 'ubuntu'. Trying fallback user 'opc'..."
            SSH_USER="opc"
            echo "SSH_USER=$SSH_USER" >> "$GITHUB_ENV"
            # Update paths for opc
            echo "DEPLOYMENT_PATH=/home/$SSH_USER/zitadel" >> "$GITHUB_ENV"
            echo "BACKUP_PATH=/home/$SSH_USER/zitadel-backups" >> "$GITHUB_ENV"
            ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "echo 'SSH connection successful'"
            SSH_STATUS=$?
          fi
          set -e
          if [ "$SSH_STATUS" -ne 0 ]; then
            echo "‚ùå SSH connection failed. Please verify that ORACLE_SSH_KEY is an unencrypted private key matching ~/.ssh/authorized_keys on the server."
            exit 1
          fi

      - name: "üìÅ Ensure Remote Deployment Directory"
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "
            sudo mkdir -p $DEPLOYMENT_PATH $BACKUP_PATH && sudo chown -R $SSH_USER:$SSH_USER $DEPLOYMENT_PATH $BACKUP_PATH
          "

      - name: "üè• Health Check - Pre Deployment"
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          echo "üîç Checking Zitadel health before deployment..."
          response=$(curl -s -o /dev/null -w "%{http_code}" https://auth.wenzelarifiandi.com/.well-known/openid-configuration || echo "000")
          if [ "$response" != "200" ]; then
            echo "‚ö†Ô∏è Zitadel is not healthy (HTTP $response), but proceeding with deployment"
          else
            echo "‚úÖ Zitadel is healthy (HTTP $response)"
          fi

      - name: "üíæ Create Backup"
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          echo "üì¶ Creating backup of current deployment..."
          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "
            # Select docker compose command
            if command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else DC='docker compose'; fi

            # Create backup directory with timestamp
            BACKUP_DIR=\"$BACKUP_PATH/backup-$(date +%Y%m%d-%H%M%S)\"
            mkdir -p \"$BACKUP_DIR\"

            # Backup configuration files
            cp -r $DEPLOYMENT_PATH/* \"$BACKUP_DIR/\" 2>/dev/null || true

            # Backup database
            cd $DEPLOYMENT_PATH
            \$DC exec -T db pg_dump -U postgres zitadel > \"$BACKUP_DIR/database.sql\" 2>/dev/null || true

            # Keep only last 5 backups
            ls -dt $BACKUP_PATH/backup-* | tail -n +6 | xargs rm -rf 2>/dev/null || true

            echo \"‚úÖ Backup created at $BACKUP_DIR\"
          "

      - name: "üöÄ Deploy Configuration"
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          echo "üöÄ Deploying new configuration..."

          # Copy new configuration files
          scp -P "$SSH_PORT" $SSH_OPTS -r zitadel/* "$SSH_USER@$SSH_HOST:$DEPLOYMENT_PATH/"

          # Execute deployment on remote server
          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "
            cd $DEPLOYMENT_PATH

            # Select docker compose command
            if command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else DC='docker compose'; fi

            echo \"üìã Current status:\"
            \$DC ps

            echo \"üîÑ Performing rolling update...\"

            # Pull latest images if needed
            \$DC pull

            # Restart services with zero downtime
            \$DC up -d --remove-orphans

            echo \"‚è≥ Waiting for services to be ready...\"
            sleep 30

            echo \"üìä New status:\"
            \$DC ps
          "

      - name: "üè• Health Check - Post Deployment"
        if: steps.changes.outputs.zitadel_changed == 'true'
        run: |
          echo "üîç Checking Zitadel health after deployment..."

          # Wait a bit more for services to stabilize
          sleep 30

          # Check OIDC endpoint
          max_attempts=10
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            echo "üîç Health check attempt $attempt/$max_attempts..."

            response=$(curl -s -o /dev/null -w "%{http_code}" https://auth.wenzelarifiandi.com/.well-known/openid-configuration || echo "000")

            if [ "$response" = "200" ]; then
              echo "‚úÖ Zitadel is healthy! Deployment successful."

              # Test console access
              console_response=$(curl -s -o /dev/null -w "%{http_code}" https://auth.wenzelarifiandi.com/ui/console || echo "000")
              if [ "$console_response" = "200" ]; then
                echo "‚úÖ Console is accessible"
              else
                echo "‚ö†Ô∏è Console returned HTTP $console_response"
              fi

              exit 0
            fi

            echo "‚ùå Health check failed (HTTP $response), retrying in 10 seconds..."
            sleep 10
            attempt=$((attempt + 1))
          done

          echo "üí• Health check failed after $max_attempts attempts"
          exit 1

      - name: "üîî Deployment Notification"
        if: always() && steps.changes.outputs.zitadel_changed == 'true'
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Deployment completed successfully!"
            echo "üåê Zitadel: https://auth.wenzelarifiandi.com"
            echo "üñ•Ô∏è Console: https://auth.wenzelarifiandi.com/ui/console"
          else
            echo "‚ùå Deployment failed!"
            echo "üîç Check the logs above for details"
            echo "üíæ Automatic backup was created before deployment"
          fi

      - name: "üÜò Rollback on Failure"
        if: failure() && steps.changes.outputs.zitadel_changed == 'true'
        env:
          ORA_SSH_KEY: ${{ secrets.ORACLE_SSH_KEY }}
        run: |
          echo "üÜò Deployment failed, initiating automatic rollback..."

          # Verify SSH key is still available
          if [ ! -f ~/.ssh/oracle_key ]; then
            echo "‚ùå SSH key not found, recreating..."
            mkdir -p ~/.ssh
            KEY_TMP=~/.ssh/oracle_key.tmp
            KEY_PATH=~/.ssh/oracle_key
            printf '%s' "${ORA_SSH_KEY}" > "$KEY_TMP"
            if grep -q '\\n' "$KEY_TMP"; then
              sed -e 's/\\r//g' -e 's/\\n/\n/g' "$KEY_TMP" > "$KEY_PATH"
            else
              tr -d '\r' < "$KEY_TMP" > "$KEY_PATH"
            fi
            rm -f "$KEY_TMP"
            if ! head -n1 "$KEY_PATH" | grep -q "BEGIN .*PRIVATE KEY"; then
              if base64 -d "$KEY_PATH" > "$KEY_PATH.dec" 2>/dev/null; then
                mv "$KEY_PATH.dec" "$KEY_PATH"
              fi
            fi
            chmod 600 "$KEY_PATH"
          fi

          ssh -p "$SSH_PORT" $SSH_OPTS "$SSH_USER@$SSH_HOST" "
            cd $DEPLOYMENT_PATH

            # Select docker compose command
            if command -v docker-compose >/dev/null 2>&1; then DC='docker-compose'; else DC='docker compose'; fi

            # Get latest backup
            LATEST_BACKUP=\$(ls -dt $BACKUP_PATH/backup-* | head -n 1)

            if [ -d \"$LATEST_BACKUP\" ]; then
              echo \"üì¶ Rolling back to: $LATEST_BACKUP\"

              # Stop services
              \$DC down

              # Restore configuration
              cp -r \"$LATEST_BACKUP\"/* ./

              # Restore database if backup exists
              if [ -f \"$LATEST_BACKUP/database.sql\" ]; then
                echo \"üóÑÔ∏è Restoring database...\"
                \$DC up -d db
                sleep 20
                \$DC exec -T db psql -U postgres -c 'DROP DATABASE IF EXISTS zitadel;'
                \$DC exec -T db psql -U postgres -c 'CREATE DATABASE zitadel;'
                \$DC exec -T db psql -U postgres zitadel < \"$LATEST_BACKUP/database.sql\"
              fi

              # Start all services
              \$DC up -d

              echo \"‚úÖ Rollback completed\"
            else
              echo \"‚ùå No backup found for rollback\"
            fi
          "

  security-scan:
    name: "üîí Security Scan & Vulnerability Check"
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - name: "üì• Checkout Code"
        uses: actions/checkout@v4

      - name: "üîß Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"
          cache-dependency-path: |
            site/package-lock.json
            studio/package-lock.json

      - name: "üîç Security Audit - Site"
        run: |
          cd site
          echo "üîç Running security audit for site dependencies..."
          npm audit --audit-level=moderate || {
            echo "‚ùå Security vulnerabilities found in site dependencies"
            echo "üîß Attempting to fix automatically..."
            npm audit fix || npm audit fix --force || true
          }

      - name: "üîç Security Audit - Studio"
        run: |
          cd studio
          echo "üîç Running security audit for studio dependencies..."
          npm audit --audit-level=moderate || {
            echo "‚ùå Security vulnerabilities found in studio dependencies"
            echo "üîß Attempting to fix automatically..."
            npm audit fix || npm audit fix --force || true
          }

      - name: "üîç Run Trivy Security Scan"
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "zitadel/"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH,MEDIUM"

      - name: "üìä Upload Trivy Results"
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: "üîê Check for Secrets"
        run: |
          echo "üîç Scanning for potential secrets..."

          # Check for common secret patterns
          if grep -r -i "password\|secret\|key\|token" zitadel/ --exclude-dir=node_modules --exclude="*.md" | grep -v "ZITADEL_MASTERKEY" | grep -v "example"; then
            echo "‚ö†Ô∏è Potential secrets found in Zitadel configuration"
            echo "Please review the above matches"
          else
            echo "‚úÖ No obvious secrets detected"
          fi

      - name: "üíæ Commit Security Fixes"
        if: success()
        run: |
          git config --local user.email "security-scan@github.com"
          git config --local user.name "Security Scanner"

          # Only consider tracked files for changes (avoid untracked scan artifacts like .cache/*.sarif)
          CHANGED=$(git diff --name-only -- site/package-lock.json site/package.json studio/package-lock.json studio/package.json || true)

          if [ -z "$CHANGED" ]; then
            echo "‚ÑπÔ∏è No security fixes needed (no tracked package files changed)"
            exit 0
          fi

          # Stage only the intended files
          git add site/package*.json studio/package*.json || true

          # If nothing ended up staged, skip committing to avoid 'nothing to commit' failures
          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è No staged changes after audit fixes; skipping commit"
            exit 0
          fi

          git commit -m "security: auto-fix vulnerabilities during deployment scan

          üîç Automated security fixes applied during deployment:
          - Updated dependencies to resolve vulnerabilities
          - Applied npm audit fixes

          ü§ñ Applied by deployment security scan
          üöÄ Generated with [Claude Code](https://claude.ai/code)

          Co-Authored-By: Security Scanner <security-scan@github.com>"

          git push
          echo "‚úÖ Security fixes applied and committed"
                      echo "‚ÑπÔ∏è No staged changes after audit fixes; skipping commit"
