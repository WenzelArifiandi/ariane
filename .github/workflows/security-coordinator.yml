name: "🎯 Security Fix Coordinator"

on:
  workflow_dispatch:
    inputs:
      strategy:
        description: "Fix strategy"
        required: true
        default: "safe"
        type: choice
        options:
          - safe
          - aggressive
          - comprehensive
  schedule:
    # Run coordinated security fixes weekly on Sundays at 1 AM UTC
    - cron: "0 1 * * 0"

permissions:
  contents: write
  actions: write
  pull-requests: write
  security-events: read

# Only one security coordinator can run at a time
concurrency:
  group: security-coordinator
  cancel-in-progress: false

jobs:
  coordinate-security-fixes:
    name: "🎯 Coordinate Security Fixes"
    runs-on: ubuntu-latest

    steps:
      - name: "📥 Checkout"
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: "🧹 Pre-cleanup: Remove Stale Branches"
        run: |
          echo "🧹 Cleaning up any existing security fix branches..."
          git fetch --all

          # Delete any existing security-fixes branches older than 1 hour
          git branch -r | grep -E "origin/security-fixes-[0-9]{8}-[0-9]{6}" | while read branch; do
            branch_name=$(echo $branch | sed 's/origin\///')
            echo "🗑️ Removing stale branch: $branch_name"
            git push origin --delete "$branch_name" 2>/dev/null || echo "Branch already deleted"
          done

      - name: "📊 Pre-fix Security Scan"
        id: pre_scan
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "📊 Starting security fix process..."

          # Try to get alert count, but don't fail if permissions are insufficient
          ALERT_COUNT=$(gh api repos/${{ github.repository }}/code-scanning/alerts --paginate 2>/dev/null | jq '[.[] | select(.state == "open")] | length' 2>/dev/null || echo "unknown")
          echo "current_alerts=$ALERT_COUNT" >> $GITHUB_OUTPUT
          echo "📈 Security alerts before fixes: $ALERT_COUNT"

      - name: "🎯 Execute Security Fix Strategy"
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          STRATEGY="${{ inputs.strategy || 'safe' }}"
          echo "🎯 Executing $STRATEGY security fix strategy..."

          case $STRATEGY in
            "safe")
              echo "🛡️ Running safe security fixes..."
              gh workflow run auto-security-fixes.yml
              ;;
            "aggressive")
              echo "🛠️ Running aggressive security fixes..."
              gh workflow run security-autofix-aggressive.yml --field fix_level=all
              ;;
            "comprehensive")
              echo "🔧 Running comprehensive security suite..."
              gh workflow run auto-security-fixes.yml
              sleep 30  # Wait to avoid conflicts
              gh workflow run security-autofix-aggressive.yml --field fix_level=all
              ;;
          esac

      - name: "⏳ Wait for Completion"
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "⏳ Waiting for security fix workflow to complete..."

          # Wait up to 10 minutes for security workflows to complete
          timeout=600
          elapsed=0
          interval=30

          while [ $elapsed -lt $timeout ]; do
            # Check if any security workflows are still running
            running_workflows=$(gh run list --workflow=auto-security-fixes.yml --status=in_progress --limit=1 --json id | jq length)
            running_aggressive=$(gh run list --workflow=security-autofix-aggressive.yml --status=in_progress --limit=1 --json id | jq length)

            if [ "$running_workflows" -eq 0 ] && [ "$running_aggressive" -eq 0 ]; then
              echo "✅ All security workflows completed"
              break
            fi

            echo "⏳ Security workflows still running... (${elapsed}s elapsed)"
            sleep $interval
            elapsed=$((elapsed + interval))
          done

          if [ $elapsed -ge $timeout ]; then
            echo "⚠️ Timeout waiting for workflows to complete"
          fi

      - name: "📊 Post-fix Security Scan"
        id: post_scan
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "📊 Security fixes completed!"

          # Try to get final alert count, but don't fail if permissions are insufficient
          ALERT_COUNT=$(gh api repos/${{ github.repository }}/code-scanning/alerts --paginate 2>/dev/null | jq '[.[] | select(.state == "open")] | length' 2>/dev/null || echo "unknown")
          echo "final_alerts=$ALERT_COUNT" >> $GITHUB_OUTPUT
          echo "📈 Security alerts after fixes: $ALERT_COUNT"

          # Calculate improvement if both counts are available
          INITIAL_COUNT="${{ steps.pre_scan.outputs.current_alerts }}"
          if [ "$INITIAL_COUNT" != "unknown" ] && [ "$ALERT_COUNT" != "unknown" ]; then
            IMPROVEMENT=$((INITIAL_COUNT - ALERT_COUNT))
            echo "improvement=$IMPROVEMENT" >> $GITHUB_OUTPUT
            echo "📉 Security improvement: $IMPROVEMENT alerts resolved"
          else
            echo "improvement=unknown" >> $GITHUB_OUTPUT
            echo "📉 Security improvement: Check repository security tab for latest counts"
          fi

      - name: "📈 Create Coordination Report"
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## 🎯 Security Fix Coordination Report

          ### 📊 Results
          - **Strategy Used**: ${{ inputs.strategy || 'safe' }}
          - **Initial Alerts**: ${{ steps.pre_scan.outputs.current_alerts }}
          - **Final Alerts**: ${{ steps.post_scan.outputs.final_alerts }}
          - **Alerts Resolved**: ${{ steps.post_scan.outputs.improvement }}
          - **Improvement**: $(( ${{ steps.post_scan.outputs.improvement }} * 100 / ${{ steps.pre_scan.outputs.current_alerts }} ))%

          ### 🛡️ Process
          1. ✅ Cleaned up stale security branches
          2. ✅ Executed coordinated security fixes
          3. ✅ Waited for completion to avoid conflicts
          4. ✅ Verified security improvements

          ### 🎯 Benefits
          - **No conflicting branches** created
          - **Coordinated execution** prevents race conditions
          - **Automatic cleanup** of temporary artifacts
          - **Measurable results** with before/after comparison
          EOF